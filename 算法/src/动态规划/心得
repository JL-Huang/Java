什么时候用动态规划？
不同的子问题具有共同的子子问题，硬解需要反复求解公共子子问题，动态规划则对每个公共子子问题只求解一次，并将其保存在一个表格中，避免反复求解
公共子子问题的解一般不是一个明确的值，更多是递归形式

动态规划方法通常用来求解最优化问题。这类问题可以有很多可解,每个解都有一个值，我们希望寻找具有最优值的解。
是一个最优解不是最优解,因为可能有多个解都达到最优值。

通常按如下4个步骤来设计一个动态规划算法:
1,刻画一个最优解的结构特征。
2.递归地定义最优解的值。
3.计算最优解的值,通常采用自底向上的方法
4.利用计算出来的信息构造一个最优解

动态规划原理：
适合应用动态规划方法求解的最优化问题应该具备两个要素：最优子结构和子问题重叠。
===========================
最优子结构：
用动态规划方法求解最优化问题的第一步就是刻画最优解的结构。
如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构性质。
但也因此，我们必须小心确保考察了最优解中用到的所有子问题。在发掘最优子结构性质的过程中，实际上遵循了如下的通用模式：
证明问题最优解的第一个组成部分是做一个选择，这次选择会产生一个或多个待解决的子问题。
对于一个给定问题，在其可能的第一步选择中，你假定已经知道哪种选择才会得到最优解。
你现在并不关心这种选择具体是如何得到的，只是假定已经知道了这种选择。
给定可获得最优解的选择后，你确定这次选择会产生哪些子问题，以及如何最好地刻画子问题空间。
作为构成原问题最优解的组成部分，每个子问题的解就是它本身的最优解。
===========================
重叠子问题：
适用动态规划方法求解的最优化问题应该具备的第二个性质是子问题空间必须足够“小”，即问题的递归算法会反复地求解相同的子问题，而不是一直生成新的子问题。
一般来讲，不同子问题的总数是输入规模的多项式函数为好。如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质。


钢条切割:
使用了一维数组存下每次切割的最优解，没有递归
===========================
矩阵链乘法：
使用了二维数组存值，为什么要用二维数组？这是由需要保存的值决定的，题解的思路是将每几个矩阵的乘积的最优解存起来，保存的乘积与起点和终点位置都相关，因此是二维
为什么钢条切割用的一维数组？因为钢条切割要存的值是每次切割后剩下部分的最优解，保存的结果只与起点位置相关，跟终点位置无关
===========================
最长公共子序列：
如果递推公式是r[i]=f(r[i+1])，则遍历顺序必须是x.length-1：0这样倒着来，反之亦然
最容易出错的点是最优子结构，想到一个子结构后，需要考虑当前结果是否仅取决于该子结构
这里保存的最优解是"可以不包含当前位的最优解"，即当前位如果不能得出更优解，则直接保存前一位的最优解，这样做最后只需要r[n]或r[0]即可得出结果
===========================
最长上升子序列：
这里保存的最优解是"必须包含当前位的最优解"，即当前位即使不能得出更优解，仍会保存当前位的解，这样做最后结果需要r[0]:r[n]排一下序
同时保存的递推公式也会不一样，r[i]不再取决于r[i-1],而是取决于max(r[0]:r:[i-1])
===========================
背包问题：
1.确定dp数组的定义，一维还是二维？
2.dp数组的递推公式？
    dp[i][j]=Math.max(dp[i-1][j]+dp[i-1][j-weight[i]]+value[i])(ij正序)
    dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);(i正序，j完全背包正序零一背包倒序)
    这两个递推干的事情实际是这样，dp[]是以每一个重量为下标保存对应最大价值的数组
    物品在外重量在内，遍历时就是先尝试把第一件物品放进不同重量的背包，第二件又从数组开头开始试，如果放进去后价值比原来大那就替换
    重量在外物品在内，遍历时就是尝试用一个重量的袋子把全部物品装一遍，随着循环逐渐增加袋子最大重量
3.怎么初始化？
    如果要求恰好装满背包，那么在初始化时除了dp[0][0]为0，其它dp[i][0]均设为−∞，这样就可以保证最终得到的dp是一种恰好装满背包的最优解。
    如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将dp[i][0]全部设为0。
4.数组遍历顺序(包括正序倒序以及循环内外层顺序)？
    如果是二维数组无论怎样都可以，但是一维数组比较特殊
    对于一维数组的零一背包，一定是物品在外重量在内且倒序的，详细解析看零一背包test2。
    对于一维数组的完全背包，物品和重量在外在内可以反转，但一定是正序