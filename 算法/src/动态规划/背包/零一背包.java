package 动态规划.背包;
/*
有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。
每件物品只能用一次，求解将哪些物品装入背包里物品价值总和最大。

dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少

不放物品i：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。
 (其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)

放物品i：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，
 那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式： dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
*/


public class 零一背包 {
    public static void main(String[] args) {
        int[] weight = {1, 3, 4};
        int[] value = {15, 20, 30};
        int bagWight = 4;
        System.out.println(test1(weight, value, bagWight));
    }

    public static int test1(int[] weight, int[] value, int W) {
//        细节之一是数组扩容一个单位
        int[][] dp = new int[weight.length][W + 1];
//        dp[i]取决于dp[i-1],因此需要初始化dp[0]
//        显然，当总重量为0价值肯定为0，因此dp[i][0]=0
//        而针对dp[0][j]，若weight[0]>j,为0，若weight[0]<=j,为value[0]
//        如果要求恰好装满背包，那么在初始化时除了dp[0][0]为0，其它dp[i][0]均设为−∞，这样就可以保证最终得到的dp是一种恰好装满背包的最优解。
//        如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将dp[i][0]全部设为 0。
        for (int i = 0; i < dp.length; i++) {
            dp[i][0] = 0;
        }
//        这一步的初始化是已经尝试将0号物品装进各个重量的背包
//        之所以要进行这一步，是因为归纳的初始条件是i=1,0号没算进去
//        像下面那种一维数组的，归纳初始条件是i=0这一步初始化就可以省略
        for (int j = 0; j < dp[0].length; j++) {
            dp[0][j] = weight[0] > j ? 0 : value[0];
        }
//        然后就开始套递推,先遍历物品后遍历背包(反过来也可以，只是没那么好理解)
//        从1号物品开始装
        for (int i = 1; i < weight.length; i++) {
//            从重量为1开始装
            for (int j = 1; j <= W; j++) {
//                如果装不下当前物品就不装了
                if (j < weight[i]) {
                    dp[i][j] = dp[i - 1][j];
                }
//                如果装得下，则比较装下后的价值和不装的价值哪个更大
                else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
                }
            }
        }
        return dp[dp.length - 1][W];
    }

    public static int test2(int[] weight, int[] value, int W) {
//        上面的递推注意到一点，之所以引入i是为了标志装前i个物品的最优价值
//        事实上，这个最优价值完全可以只通过重量来标志，因为装物品的过程是一个没有回溯不断向前的过程
        int[] dp = new int[W + 1];
//        为什么不用初始化？
        for (int i = 0; i < weight.length; i++) {
//            从最大号开始，尝试将遍历到的物品放进背包
//            这里有个细节j >= weight[i]，装不下的直接不处理，免得数组下标越界
//            for (int j =  weight[i]; j <= W; j++) {
            for (int j = W; j >= weight[i]; j--) {
//                第一次外循环将0号物品放进了各个重量的背包
//                第二次外循环其实是变成了两个背包
//                一个背包只装0号物品，另一个尝试装1号物品，往后2号3号……依次类推
//                这里很奇怪，一般如果r[i]=f(r[i-1])都是从小往大遍历，这里是反过来，而且正着还会出错……
//                至于为什么背包重量不能正序？可以看一下下面的例子，正着遍历会重复放下一个物品
//                那为什么反着就不会呢？因为反着装的时候，对于每次遍历到的物品小背包还没尝试去装，因此不会重复装同一个
//                然而这恰好就是完全背包的解，很神奇
//                至于为什么二维数组不会出现这样的情况
//                二维数组中同样是拆成两个小包装，也同样是取已经装的之前物品的价值加上装上当前物品的价值
//                但遍历物品i时已经装的之前物品的价值dp[i-1][j-weight[i]]并没有更新，而一维正序dp[j-weight[i]]是又更新了一次
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
                //倒叙遍历是为了保证物品i只被放入一次！如果一旦正序遍历了，那么物品0就会被重复加入多次！
                //举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15
                //如果正序遍历
                //dp[1] = dp[1 - weight[0]] + value[0] = 15
                //dp[2] = dp[2 - weight[0]] + value[0] = 30
                //此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。
                //为什么倒叙遍历，就可以保证物品只放入一次呢？
                //倒叙就是先算dp[2]
                //dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）
                //dp[1] = dp[1 - weight[0]] + value[0] = 15
                //所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。
                //那么问题又来了，为什么二维dp数组历的时候不用倒叙呢？
                //因为对于二维dp，dp[i][j]都是通过上一层即dp[i - 1][j]计算而来，本层的dp[i][j]并不会被覆盖！
                //为什么要物品在外重量在内呢？
                //这是因为在一维数组中，因为如果遍历重量放在上一层，那么在上述倒序的情况下，每个dp[j]就只会放入一个物品
            }
        }
        return dp[W];
    }
}
