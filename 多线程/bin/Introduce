--进程:作为资源分配的单位，每个进程都有独立的代码和数据空间，没有线程的进程可以看作单线程
--线程:
	1.调度和执行的的单位，同一进程共享代码和数据单位，线程组共享其所属进程的资源，是进程的一部分
	2.除了CPU以外，不会为线程分配内存main是主线程，进程开辟后由调度器安排调度，不能人为操作，
	3.对同一份资源操作会存在资源抢夺问题，需要加入并发控制
	4.线程默认是用户线程，设为守护线程后，系统不等守护线程执行完JVM就可以停止
	5.进程的四种状态：新生，就绪，阻塞，运行，死亡
					new,runnable,
					waiting(等待另一个线程执行完毕),
					timedwaiting(等待另一个线程达到指定等待时间)
	（1）进入新生:new
	（2）进入就绪:start，阻塞解除，yield，JVM切换
	（3）进入阻塞:sleep（抱着资源睡觉，不释放锁），
				wait(blocked等待监控器锁定，会释放锁)，
				join（插队），
				IO操作readwrite
	（4）进入死亡:stop，destroy，自然接受
--线程同步：
	1.队列
	线程同步：多个线程访问同时访问或修改一个对象时，线程进入等待池形成队列，前面线程使用完后后面才使用
	2.锁
	当一个线程获得对象的排他锁，独占资源，其他线程必须等待，线程使用后释放
	一个对象被锁住时。其他线程仍可调用和修改该对象，只是不能获得该对象的锁
	synchronized是让资源进入锁池，只有当对象其他的锁被释放，当前锁获得锁后才到就绪状态
	加锁，释放会造成资源调度问题，降低性能
--死锁：
	多个线程各自占有一些共享资源，而且互相需要等待其他线程释放资源才能进行。
	某一个同步块同时有两个以上对象锁时容易发生
--阻塞与锁：阻塞与锁是完全不同的概念，阻塞是指进程停止运行，锁是资源被线程占有
--生产者消费者模式：
生产出来的产品放仓库，消费者排队去取。没有产品时通知消费者等待，生产了产品后通知消费者来取，消费之后又要通知生产
--管程法：
生产者负责生产数据的模块
消费者负责处理数据的模块
仓库是一个缓冲区
--信号灯法：
某一时段生产者生产，某一时段消费者消费
--volatile：保证线程间变量的可见性
线程从主内存复制变量到关工作内存，修改后再返回到主内存，volatile可以保证其他线程读到的一定是修改后的
但是不能保证原子性，即复制修改返回三个操作是分开的，有可能被别的线程打断
原理：当CPU写的时候会检测其他线程的工作内存是否有当前volatile变量，有则发信号通知他们该变量地址无效，需要重新读取
不能保证原子性，是因为复制-写入-返回三个操作，如果其他线程已经执行到返回这一步，就不能做到实时修改了
线程对主存变量操作有read，load，use,assign，store，write几个过程，如果use操作过于频繁，可能导致不执行read
volatile禁止重排：volatile变量写若在volatile变量读之前，不允许两者重排，第一个操作是volatile变量读，不允许与后面
重排，第一个操作是volatile变量写，不允许与前面重排，
				
	