# 四大组件
## app启动
#### launcher
-----startactivity binder----->
#### ams
-----socket Process.start----->
#### zygote
-----------fork------>
#### app进程
----attach绑定ams与applicationthread binder----->
#### ams
--------scheduleLaunchActivity binder-->
#### applicationthread
--LAUNCH_ACTIVITY handler-->
#### activitythread
------Activity.onCreate()

## 为什么创建activity用socket不用binder
1. fork只支持单线程，因为fork出来的子进程会复制父进程的所有内容，包括父进程的所有线程状态，如果是阻塞会一直阻塞造成死锁
   binder需要多线程支持，所以不能采用binder
   进阶：其实fork之前通信已经结束，是binder驱动里的设计不支持fork
2. 子进程使用binder时，新建ProcessState，单例还是父进程的引用，里面会有操作open_driver涉及写操作，需要mmap申请一片内存用以提供给内核进行数据交换使用。
   而如果zygote使用了binder，因为子进程是fork出来的，子进程在进行binder通信时，内核还是会继续使用父进程申请的地址写数据，而此时会触发子进程COW(Copy on Write)，从而导致地址空间已经重新映射，而子进程还尝试访问之前父进程mmap的地址，会导致SIGSEGV、SEGV_MAPERR段错误。


## ActivityManagerService是什么？什么时候初始化的？有什么作用？
ActivityManagerService 主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责
与操作系统中的进程管理和调度模块类似。
ActivityManagerService进行初始化的时机很在SystemServer进程开启的时候
如果打开一个App的话，需要AMS去通知zygote进程， 所有的Activity的生命周期AMS来控制

## Instrumentation是什么？和ActivityThread是什么关系？
AMS与ActivityThread之间诸如Activity的创建、暂停等的交互工作实际上是由Instrumentation具体操作的。每
个Activity都持有一个Instrumentation对象的一个引用， 整个进程中是只有一个Instrumentation。

## Context
Android进程跟Linux进程有什么不同呢？
1. 获取应用资源，譬如：drawable、string、assets
2. 操作文件目录，譬如：获取/data/分区的数据目录、获取sdcard目录
3. 操作四大组件，譬如：启动界面、发送广播、绑定服务、打开数据库
4. 检查授予权限
5. 获取其他服务，有一些服务有专门的提供者，譬如：包管理服务、Activity管理服务、窗口管理服务
如果没有context，比如访问资源文件，就得专门去解析xml文件，有了context就可以定义一个接口以及实现，在context就封装好实现
https://duanqz.github.io/assets/images/context/2-context-class-diagram.png
### 为什么不直接继承ContextImpl
如果删除了某个方法，直接继承在所有调这个方法的地方都得改，装饰器模式就可以直接在wrapper里面改一处就行

##  为什么Fragment用Bundlebundle传递参数，而不是通过构造方法直接来传递参数？
Fragment重建时会调用默认的无参构造，但是bundle会留下

## 广播应用场景
同一 App 内部的不同组件之间的消息通信（单个进程）；
不同 App 之间的组件之间消息通信；
Android系统在特定情况下与App之间的消息通信，如：网络变化、电池电量、屏幕开关等。
## 广播的两种注册方式的区别
静态注册：常驻系统，不受组件生命周期影响，即便应用退出，广播还是可以被接收，耗电、占内存。
动态注册：非常驻，跟随组件的生命变化，组件结束，广播结束。在组件结束前，需要先移除广播，否则容易造
成内存泄漏。

## ContentProvider
ContentProvider的作用是为不同的应用之间数据共享，提供统一的接口
ContentProvider（内容提供者）通过 uri 来标识其它应用要访问的数据