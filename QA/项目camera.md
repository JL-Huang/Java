## 相机模块
### 怎么选型的？

#### 自己开发or第三方库？
相机主要是（1.预览2.图片分析处理3.拍摄）3个工作<br>
大部分相机相关库是图片分析处理，如zxing二维码，我们主要业务在预览和拍摄<br>
一些库做的不错，自动权限管理，自动处理图片旋转<br>
但是要满足业务定制，比如统一初始化权限，检测fov角度最大的摄像头等改动较大<br>
而且本质也是在官方库上改造，决定参考改造<br>
#### camera2 or camerax？
对比<br>
1. camera2更多满足自定义操作，如手动控制曝光
2. camerax适配性更好
（camera2可能获取某个摄像头拍出来是黑色）
（拍摄指定分辨率图片，camera2需要获取所有分辨率列表，然后自己实现选取，camerax可以输入后会自动选择最接近的分辨率）
场景<br>
需要适配更多设备<br>
Camerax在资源管理以及机型适配上会更优秀，比如
调用cameraDevice.createCaptureRequest创建一个请求时，会空指针异常
原因是cameraDevice还没初始化，而他没提供一个回调告诉我什么时候初始化完成，只有轮询或定时触发才能解决，不同机型初始化需要的时间不一样
所以这个不好解决，但是camerax没有这个问题

遇到什么问题？做了什么优化？效果如何？
问题1：
问题2：
全景大图bitmap展示
1. 格式优化，ARGB_8888更改为RGB_565：大小缩小一半，但是清晰度下降
2. 尺寸优化，裁剪到跟imageview一样大，inSampleSize
3. 内存复用优化，BitmapPool中传入宽高与格式，得到一个可以复用的bitmap对象
4. 分块加载:BitmapRegionDecoder,传入坐标
glide框架缓存机制
   封装参数，解析路径，压缩，缓存，编码解码，资源回收
活动缓存：防止正在显示的照片被lru清除掉
内存缓存：防止应用重复将图片读入到内存
磁盘缓存：防止应用重复的从网络或者其他地方下载和读取数据
3. 写入顺序： 弱引用缓存-》Lru算法缓存-》磁盘缓存中
   当图片不存在的时候，先从网络下载图片，然后将图片存入弱引用中，glide会采用一个acquired（int）变量用来记录图片被引用的次数，
   当acquired变量大于0的时候，说明图片正在使用中，也就是将图片放到弱引用缓存当中；
   如果acquired变量等于0了，说明图片已经不再被使用了，那么此时会调用方法来释放资源，首先会将缓存图片从弱引用中移除，然后再将它put到LruResourceCache当中。
   这样也就实现了正在使用中的图片使用弱引用来进行缓存，不在使用中的图片使用LruCache来进行缓存的功能。
如果WeakReference中也没有图片，则从磁盘缓存/网络中加载图片。
4. 获取顺序： Lru算法缓存-》弱引用缓存-》磁盘缓存
   先去LruCache中寻找图片，如果LruCache中有，则直接取出来使用，并将该图片放入WeakReference中
   如果LruCache中没有，则去WeakReference中寻找，如果WeakReference中有，则从WeakReference中取出图片使用
   Lru算法缓存命中率更高
生命周期
其实是创建了一个透明的RequestManagerFragment，所以生命周期会跟activity绑定
如果在非生命周期的组件上进行时，会采用Application 的生命周期贯穿整个应用，所以 applicationManager 只有在应用程序关闭的时候终止加载。

### LRU
LinkedHashmap插入的顺序和遍历的顺序是一致